<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Low-level building blocks · DynamicHMC.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DynamicHMC.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li><a class="toctext" href="../api/">High-level API</a></li><li class="current"><a class="toctext" href>Low-level building blocks</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Low-level-building-blocks-1">Low-level building blocks</a></li><li><a class="toctext" href="#Hamiltonian-and-leapfrog-1">Hamiltonian and leapfrog</a></li><li><a class="toctext" href="#Finding-initial-stepsize-\\epsilon-1">Finding initial stepsize <span>$\epsilon$</span></a></li><li><a class="toctext" href="#Dual-averaging-1">Dual averaging</a></li><li><a class="toctext" href="#Abstract-trajectory-interface-1">Abstract trajectory interface</a></li><li><a class="toctext" href="#Proposals-1">Proposals</a></li><li><a class="toctext" href="#Divergence-statistics-1">Divergence statistics</a></li><li><a class="toctext" href="#Turn-analysis-1">Turn analysis</a></li><li><a class="toctext" href="#Sampling-1">Sampling</a></li><li><a class="toctext" href="#Utilities-and-miscellanea-1">Utilities and miscellanea</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Low-level building blocks</a></li></ul><a class="edit-page" href="https://github.com/tpapp/DynamicHMC.jl/blob/master/docs/src/lowlevel.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Low-level building blocks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Notation-1" href="#Notation-1">Notation</a></h1><p>Notation follows <a href="https://arxiv.org/abs/1701.02434">Betancourt (2017)</a>, with some differences.</p><p>Instead of energies, <em>negative</em> energies are used in the code.</p><p>The following are used consistently for variables:</p><ul><li><p><code>ℓ</code>: log density we sample from, see <a href="../api/#ell-tutorial-1">this explanation</a></p></li><li><p><code>κ</code>: distribution/density that corresponds to kinetic energy</p></li><li><p><code>H</code>: Hamiltonian</p></li><li><p><code>q</code>: position</p></li><li><p><code>p</code>: momentum</p></li><li><p><code>z</code>: point in phase space (q,p)</p></li><li><p><code>ϵ</code>: stepsize</p></li><li><p><code>a</code>: acceptance rate</p></li><li><p><code>A</code>: acceptance tuning state</p></li><li><p><code>ζ</code>: proposal from trajectory (phase point and weight)</p></li><li><p><code>τ</code>: turn statistic</p></li><li><p><code>d</code>: divergence statistic</p></li><li><p><code>π</code>: log density (<strong>different from papers</strong>)</p></li><li><p><code>Δ</code>: logdensity relative to initial point of trajectory</p></li></ul><h1><a class="nav-anchor" id="Low-level-building-blocks-1" href="#Low-level-building-blocks-1">Low-level building blocks</a></h1><p>This is documented only for package developers. These are not part of the public API, if you are using them you should reconsider or file an issue.</p><h2><a class="nav-anchor" id="Hamiltonian-and-leapfrog-1" href="#Hamiltonian-and-leapfrog-1">Hamiltonian and leapfrog</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.Hamiltonian" href="#DynamicHMC.Hamiltonian"><code>DynamicHMC.Hamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Hamiltonian(ℓ, κ)</code></pre><p>Construct a Hamiltonian from the log density <code>ℓ</code>, and the kinetic energy specification <code>κ</code>. Calls of <code>ℓ</code> with a vector are expected to return a value that supports <code>DiffResults.value</code> and <code>DiffResults.gradient</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L101-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.PhasePoint" href="#DynamicHMC.PhasePoint"><code>DynamicHMC.PhasePoint</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A point in phase space, consists of a position and a momentum.</p><p>Log densities and gradients are saved for speed gains, so that the gradient of ℓ at q is not calculated twice for every leapfrog step (both as start- and endpoints).</p><p>Because of caching, a <code>PhasePoint</code> should only be used with a specific Hamiltonian.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L135-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.get_ℓq" href="#DynamicHMC.get_ℓq"><code>DynamicHMC.get_ℓq</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_ℓq(z)</code></pre><p>The value returned by <code>ℓ</code> when evaluated at position <code>q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L159-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.phasepoint_in" href="#DynamicHMC.phasepoint_in"><code>DynamicHMC.phasepoint_in</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">phasepoint_in(H::Hamiltonian, q, p)</code></pre><p>The recommended interface for creating a phase point in a Hamiltonian. Computes cached values.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L166-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.rand_phasepoint" href="#DynamicHMC.rand_phasepoint"><code>DynamicHMC.rand_phasepoint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rand_phasepoint(rng, H, q)</code></pre><p>Extend a position <code>q</code> to a phasepoint with a random momentum according to the kinetic energy of <code>H</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L174-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.neg_energy" href="#DynamicHMC.neg_energy"><code>DynamicHMC.neg_energy</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">neg_energy(κ, p, [q])</code></pre><p>Return the log density of kinetic energy <code>κ</code>, at momentum <code>p</code>. Some kinetic energies (eg Riemannian geometry) will need <code>q</code>, too.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L82-L87">source</a><div><p>Log density for Hamiltonian <code>H</code> at point <code>z</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L182-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.get_p♯" href="#DynamicHMC.get_p♯"><code>DynamicHMC.get_p♯</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_p♯(κ, p, [q])</code></pre><p>Return <span>$psharp$</span>, used for turn diagnostics.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L90-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.leapfrog" href="#DynamicHMC.leapfrog"><code>DynamicHMC.leapfrog</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">leapfrog(H, z, ϵ)</code></pre><p>Take a leapfrog step of length <code>ϵ</code> from <code>z</code> along the Hamiltonian <code>H</code>.</p><p>Return the new position.</p><p>The leapfrog algorithm uses the gradient of the next position to evolve the momentum. If this is not finite, the momentum won&#39;t be either. Since the constructor <code>PhasePoint</code> validates its arguments, this can only happen for divergent points anyway, and should not cause a problem.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L190-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.is_valid_ℓq" href="#DynamicHMC.is_valid_ℓq"><code>DynamicHMC.is_valid_ℓq</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">is_valid_ℓq(ℓq)</code></pre><p>Test that a value returned by ℓ is <em>valid</em>, in the following sense:</p><ol><li><p>supports <code>DiffResults.value</code> and <code>DiffResults.gradient</code> (when not, a</p></li></ol><p><code>MethodError</code> is thrown),</p><ol><li><p>the value is a float, either <code>-Inf</code> or finite,</p></li><li><p>the gradient is finite when the value is; otherwise the gradient is ignored.</p></li></ol></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L117-L128">source</a></section><h2><a class="nav-anchor" id="Finding-initial-stepsize-\\epsilon-1" href="#Finding-initial-stepsize-\\epsilon-1">Finding initial stepsize <span>$\epsilon$</span></a></h2><p>General rootfinding algorithms.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.bracket_zero" href="#DynamicHMC.bracket_zero"><code>DynamicHMC.bracket_zero</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bracket_zero(f, x, Δ, C; maxiter)</code></pre><p>Find <code>x₁</code>, <code>x₂′</code> that bracket <code>f(x) = 0</code>. <code>f</code> should be monotone, use <code>Δ &gt; 0</code> for increasing and <code>Δ &lt; 0</code> decreasing <code>f</code>.</p><p>Return <code>x₁, f(x₁), x₂′, f(x₂′)</code>. <code>x₁</code> and `x₂′ are not necessarily ordered.</p><p>Algorithm: start at the given <code>x</code>, adjust by <code>Δ</code> — for increasing <code>f</code>, use <code>Δ &gt; 0</code>. At each step, multiply <code>Δ</code> by <code>C</code>. Stop and throw an error after <code>maxiter</code> iterations.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L219-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.find_zero" href="#DynamicHMC.find_zero"><code>DynamicHMC.find_zero</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">find_zero(f, a, b, tol; [fa], [fb], [maxiter])</code></pre><p>Use bisection to find <span>$x ∈ [a,b]$</span> such that <code>|f(x)| &lt; tol</code>. When <code>f</code> is costly, specify <code>fa</code> and <code>fb</code>.</p><p>When does not converge within <code>maxiter</code> iterations, throw an error.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L253-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.bracket_find_zero" href="#DynamicHMC.bracket_find_zero"><code>DynamicHMC.bracket_find_zero</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bracket_find_zero(f, x, Δ, C, tol; [maxiter_bracket], [maxiter_bisection])</code></pre><p>A combination of <a href="#DynamicHMC.bracket_zero"><code>bracket_zero</code></a> and <a href="#DynamicHMC.bracket_find_zero"><code>bracket_find_zero</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L280-L284">source</a></section><p>Local stepsize tuning.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.logϵ_residual" href="#DynamicHMC.logϵ_residual"><code>DynamicHMC.logϵ_residual</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logϵ_residual(H, z, a)</code></pre><p>Return a function that calculates <code>A(logϵ)-a</code>, where <code>logϵ</code> is the log of the stepsize, <code>A</code> is the acceptance rate for a single leapfrog step, and <code>a</code> is the target.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L292-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.find_reasonable_logϵ" href="#DynamicHMC.find_reasonable_logϵ"><code>DynamicHMC.find_reasonable_logϵ</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">find_reasonable_logϵ(H, z; tol, a, ϵ₀, maxiter_bracket, maxiter_bisection)</code></pre><p>Let</p><p><span>$z′(ϵ) = leapfrog(H, z, ϵ)$</span></p><p>and</p><p><span>$A(ϵ) = exp(neg_energy(H, z′) - neg_energy(H, z))$</span></p><p>denote the ratio of densities between a point <code>z</code> and another point after one leapfrog step with stepsize <code>ϵ</code>.</p><p>Returns an <code>ϵ</code> such that <code>|log(A(ϵ)) - log(a)| ≤ tol</code>. Uses iterative bracketing (with gently expanding steps) and rootfinding.</p><p>Starts at <code>ϵ₀</code>, uses <code>maxiter</code> iterations for the bracketing and the rootfinding, respectively.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L307-L326">source</a></section><h2><a class="nav-anchor" id="Dual-averaging-1" href="#Dual-averaging-1">Dual averaging</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.DualAveragingParameters" href="#DynamicHMC.DualAveragingParameters"><code>DynamicHMC.DualAveragingParameters</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Parameters for the dual averaging algorithm of Gelman and Hoffman (2014, Algorithm 6).</p><p>To get reasonable defaults, initialize with <code>DualAveragingParameters(logϵ₀)</code>. See <a href="#DynamicHMC.adapting_ϵ"><code>adapting_ϵ</code></a> for a joint constructor.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L336-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.DualAveragingAdaptation" href="#DynamicHMC.DualAveragingAdaptation"><code>DynamicHMC.DualAveragingAdaptation</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Current state of adaptation for <code>ϵ</code>. Use <code>DualAverageingAdaptation(logϵ₀)</code> to get an initial value. See <a href="#DynamicHMC.adapting_ϵ"><code>adapting_ϵ</code></a> for a joint constructor.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L369-L371">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.get_ϵ" href="#DynamicHMC.get_ϵ"><code>DynamicHMC.get_ϵ</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_ϵ(A, tuning = true)</code></pre><p>When <code>tuning</code>, return the stepsize <code>ϵ</code> for the next HMC step. Otherwise return the tuned <code>ϵ</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L378-L383">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.adapting_ϵ" href="#DynamicHMC.adapting_ϵ"><code>DynamicHMC.adapting_ϵ</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">DA_params, A = adapting_ϵ(ϵ; args...)</code></pre><p>Constructor for both the adaptation parameters and the initial state.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L389-L393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.adapt_stepsize" href="#DynamicHMC.adapt_stepsize"><code>DynamicHMC.adapt_stepsize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A′ = adapt_stepsize(parameters, A, a)</code></pre><p>Update the adaptation <code>A</code> of log stepsize <code>logϵ</code> with average Metropolis acceptance rate <code>a</code> over the whole visited trajectory, using the dual averaging algorithm of Gelman and Hoffman (2014, Algorithm 6). Return the new adaptation.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L399-L405">source</a></section><h2><a class="nav-anchor" id="Abstract-trajectory-interface-1" href="#Abstract-trajectory-interface-1">Abstract trajectory interface</a></h2><p>In contrast to other reference implementations, the algorithm is implemented in a functional style using immutable values. The intention is to provide more transparency and facilitate fine-grained unit testing.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.adjacent_tree" href="#DynamicHMC.adjacent_tree"><code>DynamicHMC.adjacent_tree</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ζ, τ, d, z = adjacent_tree(rng, trajectory, z, depth, fwd)</code></pre><p>Traverse the tree of given <code>depth</code> adjacent to point <code>z</code> in <code>trajectory</code>.</p><p><code>fwd</code> specifies the direction, <code>rng</code> is used for random numbers.</p><p>Return:</p><ul><li><p><code>ζ</code>: the proposal from the tree. Only valid when <code>!isdivergent(d) &amp;&amp; !isturning(τ)</code>, otherwise the value should not be used.</p></li><li><p><code>τ</code>: turn statistics. Only valid when <code>!isdivergent(d)</code>.</p></li><li><p><code>d</code>: divergence statistics, always valid.</p></li><li><p><code>z</code>: the point at the end of the tree.</p></li></ul><p><code>trajectory</code> should support the following interface:</p><ul><li><p>Starting from leaves: <code>ζ, τ, d = leaf(trajectory, z, isinitial)</code></p></li><li><p>Moving along the trajectory: <code>z = move(trajectory, z, fwd)</code></p></li><li><p>Testing for turning and divergence: <code>isturning(τ)</code>, <code>isdivergent(d)</code></p></li><li><p>Combination of return values: <code>combine_proposals(ζ₁, ζ₂, bias)</code>, <code>combine_turnstats(τ₁, τ₂)</code>, and <code>combine_divstats(d₁, d₂)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L436-L464">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.Termination" href="#DynamicHMC.Termination"><code>DynamicHMC.Termination</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Reason for terminating a trajectory.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L482">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.sample_trajectory" href="#DynamicHMC.sample_trajectory"><code>DynamicHMC.sample_trajectory</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ζ, d, termination, depth = sample_trajectory(rng, trajectory, z, max_depth)</code></pre><p>Sample a <code>trajectory</code> starting at <code>z</code>.</p><p>Return:</p><ul><li><p><code>ζ</code>: proposal from the tree</p></li><li><p><code>d</code>: divergence statistics</p></li><li><p><code>termination</code>: reason for termination (see <a href="#DynamicHMC.Termination"><code>Termination</code></a>)</p></li><li><p><code>depth</code>: the depth of the tree that as sampled from. Doubling steps that lead to an invalid tree do not contribute to <code>depth</code>.</p></li></ul><p>See <a href="#DynamicHMC.adjacent_tree"><code>adjacent_tree</code></a> for the interface that needs to be supported by <code>trajectory</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L485-L503">source</a></section><h2><a class="nav-anchor" id="Proposals-1" href="#Proposals-1">Proposals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.Proposal" href="#DynamicHMC.Proposal"><code>DynamicHMC.Proposal</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Proposal that is propagated through by sampling recursively when building the trees.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L529-L532">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.combined_logprob_logweight" href="#DynamicHMC.combined_logprob_logweight"><code>DynamicHMC.combined_logprob_logweight</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logprob, ω = combined_logprob_logweight(ω₁, ω₂, bias)</code></pre><p>Given (relative) log probabilities <code>ω₁</code> and <code>ω₂</code>, return the log probabiliy of drawing a sampel from the second (<code>logprob</code>) and the combined (relative) log probability (<code>ω</code>).</p><p>When <code>bias</code>, biases towards the second argument, introducing anti-correlations.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L540-L548">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.combine_proposals" href="#DynamicHMC.combine_proposals"><code>DynamicHMC.combine_proposals</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">combine_proposals(rng, ζ₁, ζ₂, bias)</code></pre><p>Combine proposals from two trajectories, using their weights.</p><p>When <code>bias</code>, biases towards the second proposal, introducing anti-correlations.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L554-L560">source</a></section><h2><a class="nav-anchor" id="Divergence-statistics-1" href="#Divergence-statistics-1">Divergence statistics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.DivergenceStatistic" href="#DynamicHMC.DivergenceStatistic"><code>DynamicHMC.DivergenceStatistic</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Divergence and acceptance statistics.</p><p>Calculated over all visited phase points (not just the tree that is sampled from).</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L572-L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.divergence_statistic" href="#DynamicHMC.divergence_statistic"><code>DynamicHMC.divergence_statistic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">divergence_statistic()</code></pre><p>Empty divergence statistic (for initial node).</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L588-L592">source</a><div><pre><code class="language-none">divergence_statistic(isdivergent, Δ)</code></pre><p>Divergence statistic for leaves. <code>Δ</code> is the log density relative to the initial point.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L595-L600">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.isdivergent" href="#DynamicHMC.isdivergent"><code>DynamicHMC.isdivergent</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isdivergent(x)</code></pre><p>Test if divergence statistic <code>x</code> indicates divergence.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L604-L608">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.combine_divstats" href="#DynamicHMC.combine_divstats"><code>DynamicHMC.combine_divstats</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">combine_divstats(x, y)</code></pre><p>Combine divergence statistics from (subtrees) <code>x</code> and <code>y</code>. A divergent subtree make a subtree divergent.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L611-L616">source</a></section><h2><a class="nav-anchor" id="Turn-analysis-1" href="#Turn-analysis-1">Turn analysis</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.TurnStatistic" href="#DynamicHMC.TurnStatistic"><code>DynamicHMC.TurnStatistic</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Statistics for the identification of turning points. See Betancourt (2017, appendix).</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L634-L637">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.combine_turnstats" href="#DynamicHMC.combine_turnstats"><code>DynamicHMC.combine_turnstats</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">combine_turnstats(x, y)</code></pre><p>Combine turn statistics of two trajectories <code>x</code> and <code>y</code>, which are assume to be adjacent and in that order.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L644-L649">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.isturning" href="#DynamicHMC.isturning"><code>DynamicHMC.isturning</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isturning(τ)</code></pre><p>Test termination based on turn statistics. Uses the generalized NUTS criterion from Betancourt (2017).</p><p>Note that this function should not be called with turn statistics returned by <a href="#DynamicHMC.leaf"><code>leaf</code></a>, ie <code>depth &gt; 0</code> is required.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L653-L661">source</a></section><h2><a class="nav-anchor" id="Sampling-1" href="#Sampling-1">Sampling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.Trajectory" href="#DynamicHMC.Trajectory"><code>DynamicHMC.Trajectory</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Representation of a trajectory, ie a Hamiltonian with a discrete integrator that also checks for divergence.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L671-L674">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.leaf" href="#DynamicHMC.leaf"><code>DynamicHMC.leaf</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ζ, τ, d = leaf(trajectory, z, isinitial)</code></pre><p>Construct a proposal, turn statistic, and divergence statistic for a single point <code>z</code> in <code>trajectory</code>. When <code>isinitial</code>, <code>z</code> is the initial point in the trajectory.</p><p>Return</p><ul><li><p><code>ζ</code>: the proposal, which should only be used when <code>!isdivergent(d)</code></p></li><li><p><code>τ</code>: the turn statistic, which should only be used when <code>!isdivergent(d)</code></p></li><li><p><code>d</code>: divergence statistic</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L693-L707">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.move" href="#DynamicHMC.move"><code>DynamicHMC.move</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">move(trajectory, z, fwd)</code></pre><p>Return next phase point adjacent to <code>z</code> along <code>trajectory</code> in the direction specified by <code>fwd</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L718-L723">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.NUTS_transition" href="#DynamicHMC.NUTS_transition"><code>DynamicHMC.NUTS_transition</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">NUTS_transition(rng, H, q, ϵ, max_depth; args...)</code></pre><p>No-U-turn Hamiltonian Monte Carlo transition, using Hamiltonian <code>H</code>, starting at position <code>q</code>, using stepsize <code>ϵ</code>. Builds a doubling dynamic tree of maximum depth <code>max_depth</code>. <code>args</code> are passed to the <code>Trajectory</code> constructor. <code>rng</code> is the random number generator used.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L766-L773">source</a></section><h2><a class="nav-anchor" id="Utilities-and-miscellanea-1" href="#Utilities-and-miscellanea-1">Utilities and miscellanea</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.rand_bool" href="#DynamicHMC.rand_bool"><code>DynamicHMC.rand_bool</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rand_bool(rng, prob)</code></pre><p>Random boolean which is <code>true</code> with the given probability <code>prob</code>.</p><p>All random numbers in this library are obtained from this function.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L422-L428">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DynamicHMC.ACCEPTANCE_QUANTILES" href="#DynamicHMC.ACCEPTANCE_QUANTILES"><code>DynamicHMC.ACCEPTANCE_QUANTILES</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Acceptance quantiles for NUTS_Statistics diagnostic summary.</p></div><a class="source-link" target="_blank" href="https://github.com/tpapp/DynamicHMC.jl/blob/f214a3b9856b68f33ea6b4369763b65771c6f970/src/DynamicHMC.jl#L1070">source</a></section><footer><hr/><a class="previous" href="../api/"><span class="direction">Previous</span><span class="title">High-level API</span></a></footer></article></body></html>
